// This module needs to take a file path, read its contents into
// memory, and send out packets. I don't know how the packet sending
// should be done at this point.

// It also needs to work with 1024- and 128-byte packets, for the
// XModem server.


// `pub mod` not needed, as this is already declared a module in main.rs.

use std::path::PathBuf;
use std::ffi::OsStr;
use std::fs::File;
use std::thread;
use std::time::Duration;
use std::io::Write;

use serialport;

#[derive(PartialEq)]
enum ChecksumMode {
    Normal,
    Conn4x,
}
	
const SOH: u8 = 0x01;
const STX: u8 = 0x02;
const EOT: u8 = 0x04;
const ACK: u8 = 0x06;
const NAK: u8 = 0x15;
const CAN: u8 = 0x18;

const SUB: u8 = 0x1a; // used as packet filler, ascii code SUB (substitute)

// from https://www.reddit.com/r/rust/comments/bk7v15/my_next_favourite_way_to_divide_integers_rounding/
fn div_up(a: usize, b: usize) -> usize {
    // We *know* that the hint is exact, this is thus precisely the amount of chunks of length `b` each
    (0..a).step_by(b).size_hint().0
}

// packet_count_offset is an adjustment to the packet-counting loop
// inside this function. For example, if the offset is 3, then the
// first packet generated by this loop will have packet number 4
// (XModem uses 1-indexed packet numbers). As such, 1 may need to be
// added to the offset to get the desired outcome.
fn data_to_128_packets(data: &Vec<u8>, mut packet_count_offset: usize, checksum_mode: ChecksumMode) -> Vec<Vec<u8>> {
    let mut packet_list = Vec::new();
    // generated even when in normal checksum mode, because it's fast
    // and might be used in the loop.
    let crc_array: [u32; 256] = init_crc_array();

    // If we always add 1 (in the calling function), we'll end up with
    // a scenario where the first packet will have a sequence number
    // of 2 instead of 1. This is mostly an issue for an object that's
    // less than 1024 bytes.
    if packet_count_offset != 0 {
	packet_count_offset += 1;
    }
    // Round up packet count because any remaining data still has to
    // fit in a packet.
    let packet_count = div_up(data.len(), 128);
    println!("packet_count is {:?}", packet_count);
    // Begin assembling packets
    for i in 0..packet_count {
	// One XModem 128-byte packet contains 128 bytes of data, plus
	// 4 metadata bytes.
	let mut packet = Vec::new();
	let mut checksum = 0u32;
	
	packet.push(SOH);
	// sequence number, when encoded in packet uses 1-indexing.
	// doing the addition this way should prevent overflow errors.
	let seq = (i + 1 + packet_count_offset) as u8;
	packet.push(seq);
	// 1's complement of the sequence number
	packet.push(255u8 - (255u8 & seq));

	// If we're on the last packet (packet_count - 1), go to the end of the file.
	// Otherwise, we'll end up reading past the end of the file and get an error.
	let loop_limit = {
	    if i == packet_count - 1 {
		data.len() % 128
	    } else {
		128
	    }
	};

	
	for j in 0..loop_limit {
	    let byte = *data.get(i * 128 + j).expect("File unexpectedly cut short!");
	    if checksum_mode == ChecksumMode::Normal {
		checksum += byte as u32;
	    }
	    packet.push(byte);
	}

	// fill rest of packet if necessary
	if loop_limit != 128 {
	    for _ in loop_limit..128 {
		if checksum_mode == ChecksumMode::Normal {
		    checksum += SUB as u32;
		}
		packet.push(SUB);
	    }
	}

	// get lowest byte of checksum
	if checksum_mode == ChecksumMode::Conn4x {
	    // calculate Conn4x checksum and get two lowest bytes
	    let crc = crc_conn4x(crc_array, packet[3..].to_vec());
	    packet.push(((crc & 0xff00u32) >> 8) as u8);
	    packet.push((crc & 0xffu32) as u8);
	} else {
	    // get lowest byte of checksum
	    packet.push((checksum & 0xffu32) as u8);
	}
	packet_list.push(packet);
    }

    return packet_list;
}

// Converted straight from Conn4x source. This is not standard with
// the CCITT CRC calculation.
fn init_crc_array() -> [u32; 256] {
    let mut crc_array: [u32; 256] = [0; 256];
    let mut i = 0usize;
    for crc in 0..16 {
	for inp in 0..16 {
	    crc_array[i] = (crc ^ inp) * 0x1081;
	    i += 1;
	}
    }
    return crc_array;
}

fn crc_conn4x(crc_array: [u32; 256], data: Vec<u8>) -> u32 {
    let mut result = 0u32;
    for e in data.iter() {
	let mut k = (result & 0xf) << 4;
	result = (result >> 4) ^ crc_array[(k as u32 + (*e as u32 & 0xfu32)) as usize];
	k = (result & 0xf) << 4;
	result = (result >> 4) ^ crc_array[(k as u32 + (*e as u32 >> 4u32)) as usize];
    }
    
    return result;
}


// Generate a list of XModem packets with Conn4x checksums. This will
// try to make 1K-byte packets, then make 128-byte packets with the
// remaining data.
fn data_to_conn4x_packets(data: &Vec<u8>) -> Vec<Vec<u8>> {
    let mut packet_list = Vec::new();
    let crc_array: [u32; 256] = init_crc_array();
    // Number of 1K-byte packets to use
    let mut packet_offset = 0usize;
    let packet_count = data.len() / 1024;
    println!("data.len() is {:?}, packet_count in conn4x_packets is {:?}", data.len(), packet_count);
    for i in 0..packet_count {
	packet_offset = i;
	
	let mut packet = Vec::new();

	packet.push(STX); // STX used to indicate 1K-byte block
	let packet_count = (i + 1) as u8;
	packet.push(packet_count);
	packet.push(255u8 - (255u8 & packet_count as u8));

	// We will always push 1024 in this loop, smaller amounts are
	// relegated to data_to_128_packets
	for j in 0..1024 {
	    let byte = *data.get(i * 1024 + j).expect("File unexpectedly cut short!");
	    packet.push(byte);
	}

	// run CRC on the data portion of the packet
	let crc = crc_conn4x(crc_array, (&packet[3..]).to_vec());
	packet.push(((crc & 0xff00u32) >> 8) as u8);
	packet.push((crc & 0xffu32) as u8);

	packet_list.push(packet);
    }

    // get what remains of the data, this is just everything after the
    // last 1K packet.
    let mut substr_128 = Vec::new();
    for i in &data[packet_count * 1024..] {
	substr_128.push(*i);
    }

    // TODO: this +1usize breaks a send smaller than 1024, because the
    // packet we try to send starts with sequence number 2.
    let mut packets_128 = data_to_128_packets(&substr_128, packet_offset, ChecksumMode::Conn4x);
    // Append both vectors together for the final list
    packet_list.append(&mut packets_128);
    println!("{:?}", packet_list);
    
    return packet_list;
}

// Looks for ack_char on `port`, returns true if char found or false if NAK found.
fn wait_for_char(port: &mut Box<dyn serialport::SerialPort>, ack_char: u8) -> bool {
    let mut buf: [u8; 1] = [0; 1];
    loop {
	match port.read(buf.as_mut_slice()) {
	    Ok(_) => {
		let byte = *buf.get(0).unwrap();
		if byte == ack_char {
		    break;
		} else if byte == NAK {
		    println!("got NAK");
		    return false;
		}
	    },
	    Err(e) => { eprintln!("error reading ACK: {:?}", e); std::process::exit(1) },
	}

	println!("waiting for ACK");
    }
    return true;
}

// The way packets are sent and responses are handled don't change.
fn send_packets(packet_list: &Vec<Vec<u8>>, port: &mut Box<dyn serialport::SerialPort>) {
    for (pos, packet) in packet_list.iter().enumerate() {
	let mut retry_count = 0;
	match port.write(packet) {
	    // TODO: I think the argument here is the number of bytes written
	    Ok(_) => {},
	    Err(e) => { eprintln!("error writing packet: {:?}", e); std::process::exit(1) },
	}

	// wait for ACK on current packet 
	if !wait_for_char(port, ACK) {
	    // TODO: switch to match
	    port.write(packet).expect("Write failed!");
	    retry_count += 1;
	    if retry_count == 3 {
		// Something deeper is wrong, give up
		std::process::exit(1);
	    }
	}
	
	println!("got ACK for packet {:?}", pos);

	// if we successfully sent the last packet, send EOT after the
	// last ACK. This will trigger another ACK, which we look for
	// below (but probably don't need to)
	if pos == packet_list.len() - 1 {
	    println!("sending EOT");
	    let wr_buf: [u8; 1] = [EOT; 1];
	    // TODO: switch to match
	    port.write(&wr_buf).expect("Write of EOT failed!");
	}
    }
    
    wait_for_char(port, ACK);
}

fn get_file_contents(path: &PathBuf) -> Vec<u8> {
    // This gives a Vec<u8>.
    // from https://www.reddit.com/r/rust/comments/dekpl5/comment/f2wminn/
    let file_contents = match std::fs::read(path) {
	Err(e) => panic!("couldn't read {}: {}", path.display(), e),
	Ok(bytes) => bytes
    };
    return file_contents;
}

// Send `path` to the calculator with Conn4x-style XModem.
pub fn send_file_conn4x(path: &PathBuf, port: &mut Box<dyn serialport::SerialPort>) {
    let file_contents = get_file_contents(path);
    
    println!("Sending file in Conn4x style");
    
    let packet_list = data_to_conn4x_packets(&file_contents);

    match port.write(&server_file_cmd(path.file_name().unwrap(), 'P')) {
	Ok(_) => {},
	Err(e) => { eprintln!("error writing packet: {:?}", e); std::process::exit(1) },
    };
    

    println!("packet list: {:?}", packet_list);
    wait_for_char(port, ACK);
    
    println!("got ACK for put command");
    println!("file_contents.len() is {:?}", file_contents.len());

    // XModem Server sends D to indicate that it's ready for a
    // Conn4x-style XModem transfer
    wait_for_char(port, 'D' as u8);
    
    // Now send packet_list to the serialport
    send_packets(&packet_list, port);
    
    println!("length of packet_list is {:?}", packet_list.len());
    
}

pub fn send_file_normal(path: &PathBuf, port: &mut Box<dyn serialport::SerialPort>) {
    let file_contents = get_file_contents(path);
    
    wait_for_char(port, NAK);
    
    let packet_list = data_to_128_packets(&file_contents, 0, ChecksumMode::Normal);
    println!("{:?}", &packet_list[0..256]);
    send_packets(&packet_list, port);

}

fn server_file_cmd(name: &OsStr, cmd: char) -> Vec<u8> {
    let mut cmd_packet: Vec<u8> = Vec::new();
    cmd_packet.push(cmd as u8);
    cmd_packet.push(((name.len() as u32 & 0xff00u32) >> 8) as u8);
    cmd_packet.push((name.len() as u32 & 0xffu32) as u8);
    let mut checksum = 0u32;
    // You can't iterate over an OsStr because it might contain
    // different encodings, so you have to convert it. You can iterate
    // over a &str, which to_str() creates.
    for c in name.to_str().unwrap().chars() {
	cmd_packet.push(c as u8);
	checksum += c as u32;
    }

    cmd_packet.push((checksum & 0xffu32) as u8);
    
    return cmd_packet;
}


// 128-byte packets sent with XModem Server are 132 bytes. The server
// always sends 128-byte packets even if the file is big enough for 1K
// XModem.
pub fn get_file_conn4x(path: &PathBuf, port: &mut Box<dyn serialport::SerialPort>, direct: &bool) {
    let mut file = File::create(path).unwrap();

    // we will push to a vector and then write to the file
    let mut file_contents: Vec<u8> = Vec::new();

    if !direct {
	// Get server ready to send file
	match port.write(&server_file_cmd(path.file_name().unwrap(), 'G')) {
	    Ok(_) => {},
	    Err(e) => { eprintln!("error writing packet: {:?}", e); std::process::exit(1) },
	};
	
	// Wait for ACK from server about command
	wait_for_char(port, ACK);

	println!("got ACK for command");
    }
    
    // Initiate first packet from calculator by sending NAK
    let mut byte_buf: [u8; 1] = [NAK];

    port.write(&byte_buf);
    let mut packet_buf = vec![0; 132];
    loop {
	// needed, because I guess the calculator has to prepare the packet
	thread::sleep(Duration::from_millis(300));
	match port.read(packet_buf.as_mut_slice()) {
	    Ok(s) => println!("read {:?} bytes", s),
	    Err(e) => { eprintln!("error reading packet: {:?}", e); std::process::exit(1) },
	};

	if packet_buf[0] == EOT {
	    println!("got EOT");
	    byte_buf = [ACK];
	    port.write(&byte_buf);
	    // transmission finished
	    break;
	} else if packet_buf[0] == CAN {
	    println!("got CAN");
	    return;
	}
	
	// verify checksum of this packet
	let mut checksum = 0u32;
	for i in &packet_buf[3..131] {
	    checksum += *i as u32;
	}

	println!("calculated checksum is {:#x}, packet checksum is {:#x}", checksum as u8, packet_buf[131]);
	if checksum as u8 == packet_buf[131] {
	    println!("checksum matches");
	    byte_buf = [ACK];
	    port.write(&byte_buf);
	    file_contents.extend_from_slice(&packet_buf[3..131]);
	}
	
	println!("{:?}", packet_buf);
    }
    file.write_all(&file_contents);
    
}
